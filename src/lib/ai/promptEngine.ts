
import OpenAI from 'openai';
import { OPENAI_API_KEY } from '../../config/constants';
import { clientProfilePrompt } from '../prompts/clientProfile';
import type { GeneratedOutput } from '../../types';

export async function generateClientBlueprint(formData: {
  niche: string;
  audience: string;
  brand: string;
  product: string;
  style: string;
  tone: string;
}): Promise<string> {
  // Validate API key
  if (!OPENAI_API_KEY) {
    throw new Error('OpenAI API key is missing. Please add it to your Supabase secrets as OPENAI_API_KEY.');
  }

  try {
    // Initialize OpenAI client with enhanced configuration
    const openai = new OpenAI({
      apiKey: OPENAI_API_KEY,
      dangerouslyAllowBrowser: true  // Required for client-side usage
    });

    console.log('Generating blueprint with data:', formData);
    
    const prompt = clientProfilePrompt(formData);
    console.log('Using prompt:', prompt);
    
    // Improved API call with error handling
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini", // Using the recommended mini model for faster generation
      messages: [
        {
          role: "system", 
          content: "You are a strategic messaging expert generating a comprehensive client growth blueprint."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 1500
    });

    // Enhanced logging for debugging
    console.log('OpenAI Response:', response);

    // Extract and validate generated text
    const generatedText = response.choices[0]?.message?.content?.trim() || '';
    
    if (!generatedText) {
      throw new Error('No content was generated by the AI. Please try again.');
    }
    
    console.log('Generated blueprint text:', generatedText.substring(0, 100) + '...');
    
    return generatedText;
  } catch (error) {
    console.error('Error generating client blueprint:', error);
    
    // More informative error handling
    if (error instanceof OpenAI.APIError) {
      console.error('OpenAI API Error details:', error.status, error.message);
      throw new Error(`OpenAI API Error: ${error.message}. Check your API key and configuration.`);
    }
    
    throw new Error('Failed to generate client blueprint. Please try again.');
  }
}

// Function to parse the generated markdown into structured data
export function parseGeneratedBlueprint(markdownText: string): GeneratedOutput {
  try {
    console.log('Parsing blueprint text:', markdownText.substring(0, 100) + '...');
    
    // Parse the markdown text to extract structured data
    const output: GeneratedOutput = {
      idealClientProfile: {
        demographics: {
          age: extractSection(markdownText, "Demographics", "Age") || extractSection(markdownText, "Ideal Client Avatar", "Age") || "Not specified",
          gender: extractSection(markdownText, "Demographics", "Gender") || extractSection(markdownText, "Ideal Client Avatar", "Gender") || "Not specified",
          location: extractSection(markdownText, "Demographics", "Location") || extractSection(markdownText, "Ideal Client Avatar", "Location") || "Not specified",
          income: extractSection(markdownText, "Demographics", "Income") || extractSection(markdownText, "Ideal Client Avatar", "Income") || "Not specified",
          education: extractSection(markdownText, "Demographics", "Education") || extractSection(markdownText, "Ideal Client Avatar", "Education") || "Not specified",
          occupation: extractSection(markdownText, "Demographics", "Occupation") || extractSection(markdownText, "Ideal Client Avatar", "Occupation") || "Not specified",
        },
        psychographics: {
          values: extractList(markdownText, "Psychographics", "Values") || extractList(markdownText, "Ideal Client Avatar", "Values") || ["Not specified"],
          interests: extractList(markdownText, "Psychographics", "Interests") || extractList(markdownText, "Ideal Client Avatar", "Interests") || ["Not specified"],
          goals: extractList(markdownText, "Psychographics", "Goals") || extractList(markdownText, "Ideal Client Avatar", "Goals") || ["Not specified"],
          challenges: extractList(markdownText, "Psychographics", "Challenges") || extractList(markdownText, "Ideal Client Avatar", "Challenges") || ["Not specified"],
          motivations: extractList(markdownText, "Psychographics", "Motivations") || extractList(markdownText, "Ideal Client Avatar", "Motivations") || ["Not specified"],
        }
      },
      jobsToBeDone: {
        struggles: extractListFromSection(markdownText, "Key Struggles", 3) || 
                  extractListFromSection(markdownText, "Primary Struggles", 3) ||
                  extractListFromSection(markdownText, "Pain Points", 3) ||
                  ["Difficulty scaling business", "Time management issues", "Marketing challenges"],
        jobs: extractListFromSection(markdownText, "Jobs To Be Done", 3) || 
              ["Create scalable systems", "Develop marketing strategy", "Build team structure"],
        marketingAngle: extractSection(markdownText, "Strategic Marketing Angle") || 
                        extractSection(markdownText, "Transformation Path") ||
                        "Position as an expert who transforms knowledge into scalable systems."
      },
      millionDollarMessages: []
    };
    
    console.log('Parsed output:', output);
    return output;
  } catch (error) {
    console.error('Error parsing generated blueprint:', error);
    throw new Error('Failed to parse generated content.');
  }
}

// Helper function to extract a specific section from the markdown
function extractSection(markdown: string, section: string, subsection?: string): string {
  try {
    const regex = subsection 
      ? new RegExp(`${subsection}[:\\s]*(.*?)(?=\\n|$)`, 'i')
      : new RegExp(`${section}[:\\s]*(.*?)(?=\\n|$)`, 'i');
    
    let content = markdown;
    
    // First find the section
    if (subsection) {
      const sectionRegex = new RegExp(`##?\\s*${section}([\\s\\S]*?)(?=##|$)`, 'i');
      const sectionMatch = markdown.match(sectionRegex);
      if (sectionMatch && sectionMatch[1]) {
        content = sectionMatch[1];
      } else {
        return "";
      }
    }
    
    const match = content.match(regex);
    return match && match[1] ? match[1].trim() : "";
  } catch (error) {
    console.error(`Error extracting section ${section}:`, error);
    return "";
  }
}

// Helper function to extract a list from a section in the markdown
function extractList(markdown: string, section: string, subsection: string): string[] {
  try {
    // Find the section content
    const sectionRegex = new RegExp(`##?\\s*${section}([\\s\\S]*?)(?=##|$)`, 'i');
    const sectionMatch = markdown.match(sectionRegex);
    
    if (!sectionMatch || !sectionMatch[1]) return [];
    
    const sectionContent = sectionMatch[1];
    
    // Find the subsection within the section
    const subsectionRegex = new RegExp(`${subsection}[:\\s]*([\\s\\S]*?)(?=\\n\\s*\\n|\\n\\s*#|$)`, 'i');
    const subsectionMatch = sectionContent.match(subsectionRegex);
    
    if (!subsectionMatch || !subsectionMatch[1]) return [];
    
    // Extract list items
    return subsectionMatch[1]
      .split('\n')
      .map(line => {
        // Remove list markers (-, *, •) and trim
        const item = line.replace(/^[-*•]\s*/, '').trim();
        return item;
      })
      .filter(item => item !== '');
  } catch (error) {
    console.error(`Error extracting list for ${section}.${subsection}:`, error);
    return [];
  }
}

// Helper function to extract list items directly from a section
function extractListFromSection(markdown: string, sectionName: string, maxItems: number = 5): string[] {
  try {
    // Find the section content
    const sectionRegex = new RegExp(`###?\\s*${sectionName}([\\s\\S]*?)(?=###|##|$)`, 'i');
    const sectionMatch = markdown.match(sectionRegex);
    
    if (!sectionMatch || !sectionMatch[1]) return [];
    
    // Extract list items
    const items = sectionMatch[1]
      .split('\n')
      .map(line => {
        // Remove list markers (-, *, •) and trim
        const item = line.replace(/^[-*•]\s*/, '').trim();
        return item;
      })
      .filter(item => item !== '')
      .slice(0, maxItems); // Limit to maxItems
    
    return items;
  } catch (error) {
    console.error(`Error extracting list from section ${sectionName}:`, error);
    return [];
  }
}
