
import OpenAI from 'openai';
import { OPENAI_API_KEY } from '../../config/constants';
import { clientProfilePrompt } from '../prompts/clientProfile';
import type { GeneratedOutput } from '../../types';

export async function generateClientBlueprint(formData: {
  niche: string;
  audience: string;
  brand: string;
  product: string;
  style: string;
  tone: string;
}): Promise<string> {
  // Enhanced API key validation
  if (!OPENAI_API_KEY || OPENAI_API_KEY.trim() === '') {
    throw new Error('OpenAI API key is missing or empty. Please check your environment variables.');
  }

  try {
    console.log('Initializing OpenAI client');
    
    // Initialize OpenAI client with enhanced configuration
    const openai = new OpenAI({
      apiKey: OPENAI_API_KEY,
      dangerouslyAllowBrowser: true  // Required for client-side usage
    });

    console.log('Generating blueprint with data:', formData);
    
    const prompt = clientProfilePrompt(formData);
    console.log('Using prompt template with input data');
    
    // Improved API call with better configuration
    const response = await openai.chat.completions.create({
      model: "gpt-4o-mini", // Using the recommended mini model for faster generation
      messages: [
        {
          role: "system", 
          content: "You are a strategic messaging expert generating a comprehensive client growth blueprint."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      temperature: 0.7,
      max_tokens: 1500,
      timeout: 60000 // 60 second timeout
    });

    console.log('OpenAI Response received:', response.choices[0]?.finish_reason);

    // Extract and validate generated text
    const generatedText = response.choices[0]?.message?.content?.trim();
    
    if (!generatedText) {
      throw new Error('No content was generated by the AI. Please try again.');
    }
    
    console.log('Generated blueprint text length:', generatedText.length);
    
    return generatedText;
  } catch (error) {
    console.error('Error generating client blueprint:', error);
    
    // More informative error handling with specific error types
    if (error instanceof OpenAI.APIError) {
      console.error('OpenAI API Error details:', error.status, error.message);
      
      if (error.status === 401) {
        throw new Error(`Authentication error: Invalid API key. Please check your OpenAI API key.`);
      } else if (error.status === 429) {
        throw new Error(`Rate limit exceeded: ${error.message}. Please try again in a few moments.`);
      } else if (error.status === 500) {
        throw new Error(`OpenAI server error: ${error.message}. Please try again later.`);
      } else {
        throw new Error(`OpenAI API Error (${error.status}): ${error.message}`);
      }
    }
    
    throw new Error(`Failed to generate client blueprint: ${error instanceof Error ? error.message : 'Unknown error'}`);
  }
}

// Function to parse the generated markdown into structured data
export function parseGeneratedBlueprint(markdownText: string): GeneratedOutput {
  try {
    console.log('Parsing blueprint text');
    
    // Parse the markdown text to extract structured data
    const output: GeneratedOutput = {
      idealClientProfile: {
        demographics: {
          age: extractSection(markdownText, "Demographics", "Age") || extractSection(markdownText, "Ideal Client Avatar", "Age") || "Not specified",
          gender: extractSection(markdownText, "Demographics", "Gender") || extractSection(markdownText, "Ideal Client Avatar", "Gender") || "Not specified",
          location: extractSection(markdownText, "Demographics", "Location") || extractSection(markdownText, "Ideal Client Avatar", "Location") || "Not specified",
          income: extractSection(markdownText, "Demographics", "Income") || extractSection(markdownText, "Ideal Client Avatar", "Income") || "Not specified",
          education: extractSection(markdownText, "Demographics", "Education") || extractSection(markdownText, "Ideal Client Avatar", "Education") || "Not specified",
          occupation: extractSection(markdownText, "Demographics", "Occupation") || extractSection(markdownText, "Ideal Client Avatar", "Occupation") || "Not specified",
        },
        psychographics: {
          values: extractList(markdownText, "Psychographics", "Values") || extractList(markdownText, "Ideal Client Avatar", "Values") || ["Not specified"],
          interests: extractList(markdownText, "Psychographics", "Interests") || extractList(markdownText, "Ideal Client Avatar", "Interests") || ["Not specified"],
          goals: extractList(markdownText, "Psychographics", "Goals") || extractList(markdownText, "Ideal Client Avatar", "Goals") || ["Not specified"],
          challenges: extractList(markdownText, "Psychographics", "Challenges") || extractList(markdownText, "Ideal Client Avatar", "Challenges") || ["Not specified"],
          motivations: extractList(markdownText, "Psychographics", "Motivations") || extractList(markdownText, "Ideal Client Avatar", "Motivations") || ["Not specified"],
        }
      },
      jobsToBeDone: {
        struggles: extractListFromSection(markdownText, "Key Struggles", 3) || 
                  extractListFromSection(markdownText, "Primary Struggles", 3) ||
                  extractListFromSection(markdownText, "Pain Points", 3) ||
                  ["Not specified"],
        jobs: extractListFromSection(markdownText, "Jobs To Be Done", 3) || 
              ["Not specified"],
        marketingAngle: extractSection(markdownText, "Strategic Marketing Angle") || 
                        extractSection(markdownText, "Transformation Path") ||
                        "Not specified"
      },
      millionDollarMessages: [] // This field is not used in the current implementation
    };
    
    console.log('Parsed output structure:', {
      hasIdealClientProfile: !!output.idealClientProfile,
      hasJobsToBeDone: !!output.jobsToBeDone
    });
    return output;
  } catch (error) {
    console.error('Error parsing generated blueprint:', error);
    throw new Error('Failed to parse generated content. Please try again.');
  }
}

// Helper function to extract a specific section from the markdown
function extractSection(markdown: string, section: string, subsection?: string): string {
  try {
    const regex = subsection 
      ? new RegExp(`${subsection}[:\\s]*(.*?)(?=\\n|$)`, 'i')
      : new RegExp(`${section}[:\\s]*(.*?)(?=\\n|$)`, 'i');
    
    let content = markdown;
    
    // First find the section
    if (subsection) {
      const sectionRegex = new RegExp(`##?\\s*${section}([\\s\\S]*?)(?=##|$)`, 'i');
      const sectionMatch = markdown.match(sectionRegex);
      if (sectionMatch && sectionMatch[1]) {
        content = sectionMatch[1];
      } else {
        return "";
      }
    }
    
    const match = content.match(regex);
    return match && match[1] ? match[1].trim() : "";
  } catch (error) {
    console.error(`Error extracting section ${section}:`, error);
    return "";
  }
}

// Helper function to extract a list from a section in the markdown
function extractList(markdown: string, section: string, subsection: string): string[] {
  try {
    // Find the section content
    const sectionRegex = new RegExp(`##?\\s*${section}([\\s\\S]*?)(?=##|$)`, 'i');
    const sectionMatch = markdown.match(sectionRegex);
    
    if (!sectionMatch || !sectionMatch[1]) return [];
    
    const sectionContent = sectionMatch[1];
    
    // Find the subsection within the section
    const subsectionRegex = new RegExp(`${subsection}[:\\s]*([\\s\\S]*?)(?=\\n\\s*\\n|\\n\\s*#|$)`, 'i');
    const subsectionMatch = sectionContent.match(subsectionRegex);
    
    if (!subsectionMatch || !subsectionMatch[1]) return [];
    
    // Extract list items
    return subsectionMatch[1]
      .split('\n')
      .map(line => {
        // Remove list markers (-, *, •) and trim
        const item = line.replace(/^[-*•]\s*/, '').trim();
        return item;
      })
      .filter(item => item !== '');
  } catch (error) {
    console.error(`Error extracting list for ${section}.${subsection}:`, error);
    return [];
  }
}

// Helper function to extract list items directly from a section
function extractListFromSection(markdown: string, sectionName: string, maxItems: number = 5): string[] {
  try {
    // Find the section content
    const sectionRegex = new RegExp(`###?\\s*${sectionName}([\\s\\S]*?)(?=###|##|$)`, 'i');
    const sectionMatch = markdown.match(sectionRegex);
    
    if (!sectionMatch || !sectionMatch[1]) return [];
    
    // Extract list items
    const items = sectionMatch[1]
      .split('\n')
      .map(line => {
        // Remove list markers (-, *, •) and trim
        const item = line.replace(/^[-*•]\s*/, '').trim();
        return item;
      })
      .filter(item => item !== '')
      .slice(0, maxItems); // Limit to maxItems
    
    return items;
  } catch (error) {
    console.error(`Error extracting list from section ${sectionName}:`, error);
    return [];
  }
}
